##########################################################################
# this script was generated by openmm-builder. to customize it further,
# you can save the file to disk and edit it with your favorite editor.
##########################################################################

#from __future__ import print_function
from simtk.openmm.app import *
from simtk.openmm import *
from simtk.unit import *
from sys import stdout

from openmmtools.elongationreporter import ElongationReporter
from openmmtools.pullingforcewrapper import PullingForceWrapper
from openmmtools.chacoreporter import ChacoReporter
import threading

import numpy as np
import IPython as ip

##############################################################################

timestep = 2.0*femtoseconds
elongation_factor = 8.0
n_steps = 500000
n_intervals = 25




class AwesomeReporter(ChacoReporter, ElongationReporter):
    pass
    
##############################################################################

pdb = PDBFile('input.pdb')
forcefield = ForceField('amber99sb.xml')

system = forcefield.createSystem(pdb.topology, nonbondedMethod=CutoffNonPeriodic, 
    constraints=HBonds, rigidWater=True, nonbondedCutoff=1.0*nanometers)

integrator = LangevinIntegrator(300*kelvin, 91.0/picoseconds, timestep)
integrator.setConstraintTolerance(0.0001)

pullingforce = PullingForceWrapper(pdb=pdb)
pullingforce.add_to_system(system)

platform = Platform.getPlatformByName('Reference')
simulation = Simulation(pdb.topology, system, integrator, platform)
simulation.context.setPositions(pdb.positions)

print 'Minimizing...'
simulation.minimizeEnergy()


simulation.context.setVelocitiesToTemperature(300*kelvin)
print 'Equilibrating...'
simulation.step(100)


simulation.reporters.append(DCDReporter('pulling.dcd', 100))
reporter = AwesomeReporter(stdout, 500, pullingforce.atom1, pullingforce.atom2,
    temperature=True, time=True, totalEnergy=True)
simulation.reporters.append(reporter)


total_time = n_steps * timestep
print 'Going for', total_time.in_units_of(picoseconds)
initial_r0 = pullingforce.get_r0()
final_r0 = elongation_factor * pullingforce.get_r0()

print 'PULLING RATE', ((final_r0 - initial_r0) / total_time).in_units_of(nanometer/nanosecond)


def run():
    for i, r0 in enumerate(np.linspace(initial_r0, final_r0, n_intervals)):
        pullingforce.set_r0(r0, simulation.context)
        simulation.step(n_steps / n_intervals)


t = threading.Thread(target=run)
t.daemon = True
t.start()
reporter.configure_traits()